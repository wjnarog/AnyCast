#define NAPI_VERSION 3

#include <napi.h>

#include <string>
#include <cstring>
#include <vector>
#include <stdlib.h> // atoi

#include "node_blf.h"

#define NODE_LESS_THAN (!(NODE_VERSION_AT_LEAST(0, 5, 4)))

namespace {

    bool ValidateSalt(const char* salt) {

        if (!salt || *salt != '$') {
            return false;
        }

        // discard $
        salt++;

        if (*salt > BCRYPT_VERSION) {
            return false;
        }

        if (salt[1] != '$') {
            switch (salt[1]) {
            case 'a':
            case 'b':
                salt++;
                break;
            default:
                return false;
            }
        }

        // discard version + $
        salt += 2;

        if (salt[2] != '$') {
            return false;
        }

        int n = atoi(salt);
        if (n > 31 || n < 0) {
            return false;
        }

        if (((uint8_t)1 << (uint8_t)n) < BCRYPT_MINROUNDS) {
            return false;
        }

        salt += 3;
        if (strlen(salt) * 3 / 4 < BCRYPT_MAXSALT) {
            return false;
        }

        return true;
    }

    inline char ToCharVersion(const std::string& str) {
        return str[0];
    }

    /* SALT GENERATION */

    class SaltAsyncWorker : public Napi::AsyncWorker {
        public:
            SaltAsyncWorker(const Napi::Function& callback, const std::string& seed, ssize_t rounds, char minor_ver)
                : Napi::AsyncWorker(callback, "bcrypt:SaltAsyncWorker"), seed(seed), rounds(rounds), minor_ver(minor_ver) {
            }

            ~SaltAsyncWorker() {}

            void Execute() {
                bcrypt_gensalt(minor_ver, rounds, (u_int8_t *)&seed[0], salt);
            }

            void OnOK() {
                Napi::HandleScope scope(Env());
                Callback().Call({Env().Undefined(), Napi::String::New(Env(), salt)});
            }

        private:
            std::string seed;
            ssize_t rounds;
            char minor_ver;
            char salt[_SALT_LEN];
    };

    Napi::Value GenerateSalt(const Napi::CallbackInfo& info) {
        Napi::Env env = info.Env();
        if (info.Length() < 4) {
            throw Napi::TypeError::New(env, "4 arguments expected");
        }
        if (!info[0].IsString()) {
            throw Napi::TypeError::New(env, "First argument must be a string");
        }
        if (!info[2].IsBuffer() || (info[2].As<Napi::Buffer<char>>()).Length() != 16) {
            throw Napi::TypeError::New(env, "Second argument must be a 16 byte Buffer");
        }

        const char minor_ver = ToCharVersion(info[0].As<Napi::String>());
        const int32_t rounds = info[1].As<Napi::Number>();
        Napi::Buffer<char> seed = info[2].As<Napi::Buffer<char>>();
        Napi::Function callback = info[3].As<Napi::Function>();
        SaltAsyncWorker* saltWorker = new SaltAsyncWorker(callback, std::string(seed.Data(), 16), rounds, minor_ver);
        saltWorker->Queue();
        return env.Undefined();
    }

    Napi::Value GenerateSaltS